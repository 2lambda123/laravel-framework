<?php namespace Illuminate\Support; use Closure; use Countable; use ArrayAccess; use ArrayIterator; use CachingIterator; use JsonSerializable; use IteratorAggregate; use Illuminate\Support\Contracts\JsonableInterface; use Illuminate\Support\Contracts\ArrayableInterface; class Collection implements ArrayAccess, ArrayableInterface, Countable, IteratorAggregate, JsonableInterface, JsonSerializable { protected $items = array(); public function __construct(array $items = array()) { $this->items = $items; } public static function make($items) { if (is_null($items)) return new static; if ($items instanceof Collection) return $items; return new static(is_array($items) ? $items : array($items)); } public function all() { return $this->items; } public function collapse() { $results = array(); foreach ($this->items as $values) { $results = array_merge($results, $values); } return new static($results); } public function diff($items) { return new static(array_diff($this->items, $this->getArrayableItems($items))); } public function each(Closure $callback) { array_map($callback, $this->items); return $this; } public function fetch($key) { return new static(array_fetch($this->items, $key)); } public function filter(Closure $callback) { return new static(array_filter($this->items, $callback)); } public function first(Closure $callback = null, $default = null) { if (is_null($callback)) { return count($this->items) > 0 ? reset($this->items) : null; } else { return array_first($this->items, $callback, $default); } } public function flatten() { return new static(array_flatten($this->items)); } public function forget($key) { unset($this->items[$key]); } public function get($key, $default = null) { if (array_key_exists($key, $this->items)) { return $this->items[$key]; } return value($default); } public function groupBy($groupBy) { $results = array(); foreach ($this->items as $key => $value) { $key = is_callable($groupBy) ? $groupBy($value, $key) : data_get($value, $groupBy); $results[$key][] = $value; } return new static($results); } public function has($key) { return array_key_exists($key, $this->items); } public function implode($value, $glue = null) { if (is_null($glue)) return implode($this->lists($value)); return implode($glue, $this->lists($value)); } public function intersect($items) { return new static(array_intersect($this->items, $this->getArrayableItems($items))); } public function isEmpty() { return empty($this->items); } public function last() { return count($this->items) > 0 ? end($this->items) : null; } public function lists($value, $key = null) { return array_pluck($this->items, $value, $key); } public function map(Closure $callback) { return new static(array_map($callback, $this->items, array_keys($this->items))); } public function merge($items) { return new static(array_merge($this->items, $this->getArrayableItems($items))); } public function pop() { return array_pop($this->items); } public function prepend($value) { array_unshift($this->items, $value); } public function push($value) { $this->items[] = $value; } public function put($key, $value) { $this->items[$key] = $value; } public function reduce($callback, $initial = null) { return array_reduce($this->items, $callback, $initial); } public function random($amount = 1) { $keys = array_rand($this->items, $amount); return is_array($keys) ? array_intersect_key($this->items, array_flip($keys)) : $this->items[$keys]; } public function reverse() { return new static(array_reverse($this->items)); } public function shift() { return array_shift($this->items); } public function slice($offset, $length = null, $preserveKeys = false) { return new static(array_slice($this->items, $offset, $length, $preserveKeys)); } public function chunk($size, $preserveKeys = false) { $chunks = new static; foreach (array_chunk($this->items, $size, $preserveKeys) as $chunk) { $chunks->push(new static($chunk)); } return $chunks; } public function sort(Closure $callback) { uasort($this->items, $callback); return $this; } public function sortBy($callback, $options = SORT_REGULAR, $descending = false) { $results = array(); if (is_string($callback)) $callback = $this->valueRetriever($callback); foreach ($this->items as $key => $value) { $results[$key] = $callback($value); } $descending ? arsort($results, $options) : asort($results, $options); foreach (array_keys($results) as $key) { $results[$key] = $this->items[$key]; } $this->items = $results; return $this; } public function sortByDesc($callback, $options = SORT_REGULAR) { return $this->sortBy($callback, $options, true); } public function splice($offset, $length = 0, $replacement = array()) { return new static(array_splice($this->items, $offset, $length, $replacement)); } public function sum($callback) { if (is_string($callback)) { $callback = $this->valueRetriever($callback); } return $this->reduce(function($result, $item) use ($callback) { return $result += $callback($item); }, 0); } public function take($limit = null) { if ($limit < 0) return $this->slice($limit, abs($limit)); return $this->slice(0, $limit); } public function transform(Closure $callback) { $this->items = array_map($callback, $this->items); return $this; } public function unique() { return new static(array_unique($this->items)); } public function values() { $this->items = array_values($this->items); return $this; } protected function valueRetriever($value) { return function($item) use ($value) { return is_object($item) ? $item->{$value} : array_get($item, $value); }; } public function toArray() { return array_map(function($value) { return $value instanceof ArrayableInterface ? $value->toArray() : $value; }, $this->items); } public function jsonSerialize() { return $this->toArray(); } public function toJson($options = 0) { return json_encode($this->toArray(), $options); } public function getIterator() { return new ArrayIterator($this->items); } public function getCachingIterator($flags = CachingIterator::CALL_TOSTRING) { return new CachingIterator($this->getIterator(), $flags); } public function count() { return count($this->items); } public function offsetExists($key) { return array_key_exists($key, $this->items); } public function offsetGet($key) { return $this->items[$key]; } public function offsetSet($key, $value) { if (is_null($key)) { $this->items[] = $value; } else { $this->items[$key] = $value; } } public function offsetUnset($key) { unset($this->items[$key]); } public function __toString() { return $this->toJson(); } private function getArrayableItems($items) { if ($items instanceof Collection) { $items = $items->all(); } elseif ($items instanceof ArrayableInterface) { $items = $items->toArray(); } return $items; } }
