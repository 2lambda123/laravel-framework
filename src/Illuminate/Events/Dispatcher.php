<?php namespace Illuminate\Events; use Illuminate\Container\Container; class Dispatcher { protected $container; protected $listeners = array(); protected $wildcards = array(); protected $sorted = array(); protected $firing = array(); public function __construct(Container $container = null) { $this->container = $container ?: new Container; } public function listen($events, $listener, $priority = 0) { foreach ((array) $events as $event) { if (str_contains($event, '*')) { return $this->setupWildcardListen($event, $listener); } $this->listeners[$event][$priority][] = $this->makeListener($listener); unset($this->sorted[$event]); } } protected function setupWildcardListen($event, $listener) { $this->wildcards[$event][] = $this->makeListener($listener); } public function hasListeners($eventName) { return isset($this->listeners[$eventName]); } public function queue($event, $payload = array()) { $this->listen($event.'_queue', function() use ($event, $payload) { $this->fire($event, $payload); }); } public function subscribe($subscriber) { $subscriber = $this->resolveSubscriber($subscriber); $subscriber->subscribe($this); } protected function resolveSubscriber($subscriber) { if (is_string($subscriber)) { return $this->container->make($subscriber); } return $subscriber; } public function until($event, $payload = array()) { return $this->fire($event, $payload, true); } public function flush($event) { $this->fire($event.'_queue'); } public function firing() { return last($this->firing); } public function fire($event, $payload = array(), $halt = false) { $responses = array(); if ( ! is_array($payload)) $payload = array($payload); $this->firing[] = $event; foreach ($this->getListeners($event) as $listener) { $response = call_user_func_array($listener, $payload); if ( ! is_null($response) && $halt) { array_pop($this->firing); return $response; } if ($response === false) break; $responses[] = $response; } array_pop($this->firing); return $halt ? null : $responses; } public function getListeners($eventName) { $wildcards = $this->getWildcardListeners($eventName); if ( ! isset($this->sorted[$eventName])) { $this->sortListeners($eventName); } return array_merge($this->sorted[$eventName], $wildcards); } protected function getWildcardListeners($eventName) { $wildcards = array(); foreach ($this->wildcards as $key => $listeners) { if (str_is($key, $eventName)) $wildcards = array_merge($wildcards, $listeners); } return $wildcards; } protected function sortListeners($eventName) { $this->sorted[$eventName] = array(); if (isset($this->listeners[$eventName])) { krsort($this->listeners[$eventName]); $this->sorted[$eventName] = call_user_func_array('array_merge', $this->listeners[$eventName]); } } public function makeListener($listener) { if (is_string($listener)) { $listener = $this->createClassListener($listener); } return $listener; } public function createClassListener($listener) { $container = $this->container; return function() use ($listener, $container) { $segments = explode('@', $listener); $method = count($segments) == 2 ? $segments[1] : 'handle'; $callable = array($container->make($segments[0]), $method); $data = func_get_args(); return call_user_func_array($callable, $data); }; } public function forget($event) { unset($this->listeners[$event]); unset($this->sorted[$event]); } }
