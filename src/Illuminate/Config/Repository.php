<?php namespace Illuminate\Config; use Closure; use ArrayAccess; use Illuminate\Support\NamespacedItemResolver; class Repository extends NamespacedItemResolver implements ArrayAccess { protected $loader; protected $environment; protected $items = array(); protected $packages = array(); protected $afterLoad = array(); public function __construct(LoaderInterface $loader, $environment) { $this->loader = $loader; $this->environment = $environment; } public function has($key) { $default = microtime(true); return $this->get($key, $default) !== $default; } public function hasGroup($key) { list($namespace, $group, $item) = $this->parseKey($key); return $this->loader->exists($group, $namespace); } public function get($key, $default = null) { list($namespace, $group, $item) = $this->parseKey($key); $collection = $this->getCollection($group, $namespace); $this->load($group, $namespace, $collection); return array_get($this->items[$collection], $item, $default); } public function set($key, $value) { list($namespace, $group, $item) = $this->parseKey($key); $collection = $this->getCollection($group, $namespace); $this->load($group, $namespace, $collection); if (is_null($item)) { $this->items[$collection] = $value; } else { array_set($this->items[$collection], $item, $value); } } protected function load($group, $namespace, $collection) { $env = $this->environment; if (isset($this->items[$collection])) { return; } $items = $this->loader->load($env, $group, $namespace); if (isset($this->afterLoad[$namespace])) { $items = $this->callAfterLoad($namespace, $group, $items); } $this->items[$collection] = $items; } protected function callAfterLoad($namespace, $group, $items) { $callback = $this->afterLoad[$namespace]; return call_user_func($callback, $this, $group, $items); } protected function parseNamespacedSegments($key) { list($namespace, $item) = explode('::', $key); if (in_array($namespace, $this->packages)) { return $this->parsePackageSegments($key, $namespace, $item); } return parent::parseNamespacedSegments($key); } protected function parsePackageSegments($key, $namespace, $item) { $itemSegments = explode('.', $item); if ( ! $this->loader->exists($itemSegments[0], $namespace)) { return array($namespace, 'config', $item); } return parent::parseNamespacedSegments($key); } public function package($package, $hint, $namespace = null) { $namespace = $this->getPackageNamespace($package, $namespace); $this->packages[] = $namespace; $this->addNamespace($namespace, $hint); $this->afterLoading($namespace, function($me, $group, $items) use ($package) { $env = $me->getEnvironment(); $loader = $me->getLoader(); return $loader->cascadePackage($env, $package, $group, $items); }); } protected function getPackageNamespace($package, $namespace) { if (is_null($namespace)) { list($vendor, $namespace) = explode('/', $package); } return $namespace; } public function afterLoading($namespace, Closure $callback) { $this->afterLoad[$namespace] = $callback; } protected function getCollection($group, $namespace = null) { $namespace = $namespace ?: '*'; return $namespace.'::'.$group; } public function addNamespace($namespace, $hint) { $this->loader->addNamespace($namespace, $hint); } public function getNamespaces() { return $this->loader->getNamespaces(); } public function getLoader() { return $this->loader; } public function setLoader(LoaderInterface $loader) { $this->loader = $loader; } public function getEnvironment() { return $this->environment; } public function getAfterLoadCallbacks() { return $this->afterLoad; } public function getItems() { return $this->items; } public function offsetExists($key) { return $this->has($key); } public function offsetGet($key) { return $this->get($key); } public function offsetSet($key, $value) { $this->set($key, $value); } public function offsetUnset($key) { $this->set($key, null); } }
