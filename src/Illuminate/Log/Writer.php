<?php namespace Illuminate\Log; use Closure; use Illuminate\Events\Dispatcher; use Monolog\Handler\StreamHandler; use Monolog\Logger as MonologLogger; use Monolog\Formatter\LineFormatter; use Monolog\Handler\RotatingFileHandler; class Writer { protected $monolog; protected $levels = array( 'debug', 'info', 'notice', 'warning', 'error', 'critical', 'alert', 'emergency', ); protected $dispatcher; public function __construct(MonologLogger $monolog, Dispatcher $dispatcher = null) { $this->monolog = $monolog; if (isset($dispatcher)) { $this->dispatcher = $dispatcher; } } protected function callMonolog($method, $parameters) { if (is_array($parameters[0])) { $parameters[0] = json_encode($parameters[0]); } return call_user_func_array(array($this->monolog, $method), $parameters); } public function useFiles($path, $level = 'debug') { $level = $this->parseLevel($level); $this->monolog->pushHandler($handler = new StreamHandler($path, $level)); $handler->setFormatter(new LineFormatter(null, null, true)); } public function useDailyFiles($path, $days = 0, $level = 'debug') { $level = $this->parseLevel($level); $this->monolog->pushHandler($handler = new RotatingFileHandler($path, $days, $level)); $handler->setFormatter(new LineFormatter(null, null, true)); } protected function parseLevel($level) { switch ($level) { case 'debug': return MonologLogger::DEBUG; case 'info': return MonologLogger::INFO; case 'notice': return MonologLogger::NOTICE; case 'warning': return MonologLogger::WARNING; case 'error': return MonologLogger::ERROR; case 'critical': return MonologLogger::CRITICAL; case 'alert': return MonologLogger::ALERT; case 'emergency': return MonologLogger::EMERGENCY; default: throw new \InvalidArgumentException("Invalid log level."); } } public function listen(Closure $callback) { if ( ! isset($this->dispatcher)) { throw new \RuntimeException("Events dispatcher has not been set."); } $this->dispatcher->listen('illuminate.log', $callback); } public function getMonolog() { return $this->monolog; } public function getEventDispatcher() { return $this->dispatcher; } public function setEventDispatcher(Dispatcher $dispatcher) { $this->dispatcher = $dispatcher; } protected function fireLogEvent($level, $message, array $context = array()) { if (isset($this->dispatcher)) { $this->dispatcher->fire('illuminate.log', compact('level', 'message', 'context')); } } public function write() { $level = head(func_get_args()); return call_user_func_array(array($this, $level), array_slice(func_get_args(), 1)); } public function __call($method, $parameters) { if (in_array($method, $this->levels)) { call_user_func_array(array($this, 'fireLogEvent'), array_merge(array($method), $parameters)); $method = 'add'.ucfirst($method); return $this->callMonolog($method, $parameters); } throw new \BadMethodCallException("Method [$method] does not exist."); } }
