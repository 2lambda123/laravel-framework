<?php namespace Illuminate\Cache; use Closure; class TaggedCache implements StoreInterface { protected $store; protected $tags; public function __construct(StoreInterface $store, TagSet $tags) { $this->tags = $tags; $this->store = $store; } public function has($key) { return ! is_null($this->get($key)); } public function get($key, $default = null) { $value = $this->store->get($this->taggedItemKey($key)); return ! is_null($value) ? $value : value($default); } public function put($key, $value, $minutes) { return $this->store->put($this->taggedItemKey($key), $value, $minutes); } public function add($key, $value, $minutes) { if (is_null($this->get($key))) { $this->put($key, $value, $minutes); return true; } return false; } public function increment($key, $value = 1) { $this->store->increment($this->taggedItemKey($key), $value); } public function decrement($key, $value = 1) { $this->store->decrement($this->taggedItemKey($key), $value); } public function forever($key, $value) { $this->store->forever($this->taggedItemKey($key), $value); } public function forget($key) { $this->store->forget($this->taggedItemKey($key)); } public function flush() { $this->tags->reset(); } public function remember($key, $minutes, Closure $callback) { if ($this->has($key)) return $this->get($key); $this->put($key, $value = $callback(), $minutes); return $value; } public function sear($key, Closure $callback) { return $this->rememberForever($key, $callback); } public function rememberForever($key, Closure $callback) { if ($this->has($key)) return $this->get($key); $this->forever($key, $value = $callback()); return $value; } public function taggedItemKey($key) { return $this->getPrefix().sha1($this->tags->getNamespace()).':'.$key; } public function getPrefix() { return $this->store->getPrefix(); } }
