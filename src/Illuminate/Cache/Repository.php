<?php namespace Illuminate\Cache; use Closure; use DateTime; use ArrayAccess; use Carbon\Carbon; use Illuminate\Support\Traits\MacroableTrait; class Repository implements ArrayAccess { use MacroableTrait { __call as macroCall; } protected $store; protected $default = 60; public function __construct(StoreInterface $store) { $this->store = $store; } public function has($key) { return ! is_null($this->get($key)); } public function get($key, $default = null) { $value = $this->store->get($key); return ! is_null($value) ? $value : value($default); } public function put($key, $value, $minutes) { $minutes = $this->getMinutes($minutes); $this->store->put($key, $value, $minutes); } public function add($key, $value, $minutes) { if (is_null($this->get($key))) { $this->put($key, $value, $minutes); return true; } return false; } public function remember($key, $minutes, Closure $callback) { if ( ! is_null($value = $this->get($key))) { return $value; } $this->put($key, $value = $callback(), $minutes); return $value; } public function sear($key, Closure $callback) { return $this->rememberForever($key, $callback); } public function rememberForever($key, Closure $callback) { if ( ! is_null($value = $this->get($key))) { return $value; } $this->forever($key, $value = $callback()); return $value; } public function getDefaultCacheTime() { return $this->default; } public function setDefaultCacheTime($minutes) { $this->default = $minutes; } public function getStore() { return $this->store; } public function offsetExists($key) { return $this->has($key); } public function offsetGet($key) { return $this->get($key); } public function offsetSet($key, $value) { $this->put($key, $value, $this->default); } public function offsetUnset($key) { return $this->forget($key); } protected function getMinutes($duration) { if ($duration instanceof DateTime) { $duration = Carbon::instance($duration); return max(0, Carbon::now()->diffInMinutes($duration, false)); } else { return is_string($duration) ? intval($duration) : $duration; } } public function __call($method, $parameters) { if (static::hasMacro($method)) { return $this->macroCall($method, $parameters); } else { return call_user_func_array(array($this->store, $method), $parameters); } } }
