<?php namespace Illuminate\Routing; use Closure; use Illuminate\Http\Request; use Illuminate\Routing\Matching\UriValidator; use Illuminate\Routing\Matching\HostValidator; use Illuminate\Routing\Matching\MethodValidator; use Illuminate\Routing\Matching\SchemeValidator; use Symfony\Component\Routing\Route as SymfonyRoute; class Route { protected $uri; protected $methods; protected $action; protected $defaults = array(); protected $wheres = array(); protected $parameters; protected $parameterNames; protected $compiled; protected static $validators; public function __construct($methods, $uri, $action) { $this->uri = $uri; $this->methods = (array) $methods; $this->action = $this->parseAction($action); if (isset($this->action['prefix'])) { $this->prefix($this->action['prefix']); } } public function run() { $parameters = array_filter($this->parameters(), function($p) { return isset($p); }); return call_user_func_array($this->action['uses'], $parameters); } public function matches(Request $request) { $this->compileRoute(); foreach ($this->getValidators() as $validator) { if ( ! $validator->matches($this, $request)) return false; } return true; } protected function compileRoute() { $optionals = $this->extractOptionalParameters(); $uri = preg_replace('/\{(\w+?)\?\}/', '{$1}', $this->uri); $this->compiled = with( new SymfonyRoute($uri, $optionals, $this->wheres, array(), $this->domain() ?: '') )->compile(); } protected function extractOptionalParameters() { preg_match_all('/\{(\w+?)\?\}/', $this->uri, $matches); $optional = array(); if (isset($matches[1])) { foreach ($matches[1] as $key) { $optional[$key] = null; } } return $optional; } public function beforeFilters() { if ( ! isset($this->action['before'])) return array(); return $this->parseFilters($this->action['before']); } public function afterFilters() { if ( ! isset($this->action['after'])) return array(); return $this->parseFilters($this->action['after']); } public static function parseFilters($filters) { return array_build(static::explodeFilters($filters), function($key, $value) { return Route::parseFilter($value); }); } protected static function explodeFilters($filters) { if (is_array($filters)) return static::explodeArrayFilters($filters); return explode('|', $filters); } protected static function explodeArrayFilters(array $filters) { $results = array(); foreach ($filters as $filter) { $results = array_merge($results, explode('|', $filter)); } return $results; } public static function parseFilter($filter) { if ( ! str_contains($filter, ':')) return array($filter, array()); return static::parseParameterFilter($filter); } protected static function parseParameterFilter($filter) { list($name, $parameters) = explode(':', $filter, 2); return array($name, explode(',', $parameters)); } public function getParameter($name, $default = null) { return $this->parameter($name, $default); } public function parameter($name, $default = null) { return array_get($this->parameters(), $name) ?: $default; } public function setParameter($name, $value) { $this->parameters(); $this->parameters[$name] = $value; } public function forgetParameter($name) { $this->parameters(); unset($this->parameters[$name]); } public function parameters() { if (isset($this->parameters)) { return array_map(function($value) { return is_string($value) ? rawurldecode($value) : $value; }, $this->parameters); } throw new \LogicException("Route is not bound."); } public function parametersWithoutNulls() { return array_filter($this->parameters(), function($p) { return ! is_null($p); }); } public function parameterNames() { if (isset($this->parameterNames)) return $this->parameterNames; return $this->parameterNames = $this->compileParameterNames(); } protected function compileParameterNames() { preg_match_all('/\{(.*?)\}/', $this->domain().$this->uri, $matches); return array_map(function($m) { return trim($m, '?'); }, $matches[1]); } public function bind(Request $request) { $this->compileRoute(); $this->bindParameters($request); return $this; } public function bindParameters(Request $request) { $params = $this->matchToKeys( array_slice($this->bindPathParameters($request), 1) ); if ( ! is_null($this->compiled->getHostRegex())) { $params = $this->bindHostParameters( $request, $params ); } return $this->parameters = $this->replaceDefaults($params); } protected function bindPathParameters(Request $request) { preg_match($this->compiled->getRegex(), '/'.$request->decodedPath(), $matches); return $matches; } protected function bindHostParameters(Request $request, $parameters) { preg_match($this->compiled->getHostRegex(), $request->getHost(), $matches); return array_merge($this->matchToKeys(array_slice($matches, 1)), $parameters); } protected function matchToKeys(array $matches) { if (count($this->parameterNames()) == 0) return array(); $parameters = array_intersect_key($matches, array_flip($this->parameterNames())); return array_filter($parameters, function($value) { return is_string($value) && strlen($value) > 0; }); } protected function replaceDefaults(array $parameters) { foreach ($parameters as $key => &$value) { $value = isset($value) ? $value : array_get($this->defaults, $key); } return $parameters; } protected function parseAction($action) { if ($action instanceof Closure) { return array('uses' => $action); } elseif ( ! isset($action['uses'])) { $action['uses'] = $this->findClosure($action); } return $action; } protected function findClosure(array $action) { return array_first($action, function($key, $value) { return $value instanceof Closure; }); } public static function getValidators() { if (isset(static::$validators)) return static::$validators; return static::$validators = array( new MethodValidator, new SchemeValidator, new HostValidator, new UriValidator, ); } public function before($filters) { return $this->addFilters('before', $filters); } public function after($filters) { return $this->addFilters('after', $filters); } protected function addFilters($type, $filters) { if (isset($this->action[$type])) { $this->action[$type] .= '|'.$filters; } else { $this->action[$type] = $filters; } return $this; } public function defaults($key, $value) { $this->defaults[$key] = $value; return $this; } public function where($name, $expression = null) { foreach ($this->parseWhere($name, $expression) as $name => $expression) { $this->wheres[$name] = $expression; } return $this; } protected function parseWhere($name, $expression) { return is_array($name) ? $name : array($name => $expression); } protected function whereArray(array $wheres) { foreach ($wheres as $name => $expression) { $this->where($name, $expression); } return $this; } public function prefix($prefix) { $this->uri = trim($prefix, '/').'/'.trim($this->uri, '/'); return $this; } public function getPath() { return $this->uri(); } public function uri() { return $this->uri; } public function getMethods() { return $this->methods(); } public function methods() { return $this->methods; } public function httpOnly() { return in_array('http', $this->action); } public function httpsOnly() { return $this->secure(); } public function secure() { return in_array('https', $this->action); } public function domain() { return array_get($this->action, 'domain'); } public function getUri() { return $this->uri; } public function setUri($uri) { $this->uri = $uri; return $this; } public function getPrefix() { return array_get($this->action, 'prefix'); } public function getName() { return array_get($this->action, 'as'); } public function getActionName() { return array_get($this->action, 'controller', 'Closure'); } public function getAction() { return $this->action; } public function setAction(array $action) { $this->action = $action; return $this; } public function getCompiled() { return $this->compiled; } }
