<?php namespace Illuminate\Routing; use Closure; use Illuminate\Http\Request; use Illuminate\Http\Response; use Illuminate\Events\Dispatcher; use Illuminate\Container\Container; use Symfony\Component\HttpKernel\HttpKernelInterface; use Symfony\Component\HttpFoundation\Request as SymfonyRequest; use Symfony\Component\HttpFoundation\Response as SymfonyResponse; use Symfony\Component\HttpKernel\Exception\NotFoundHttpException; class Router implements HttpKernelInterface, RouteFiltererInterface { protected $events; protected $container; protected $routes; protected $current; protected $currentRequest; protected $controllerDispatcher; protected $inspector; protected $filtering = true; protected $patternFilters = array(); protected $regexFilters = array(); protected $binders = array(); protected $patterns = array(); protected $groupStack = array(); public static $verbs = array('GET', 'HEAD', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS'); protected $resourceDefaults = array('index', 'create', 'store', 'show', 'edit', 'update', 'destroy'); public function __construct(Dispatcher $events, Container $container = null) { $this->events = $events; $this->routes = new RouteCollection; $this->container = $container ?: new Container; $this->bind('_missing', function($v) { return explode('/', $v); }); } public function get($uri, $action) { return $this->addRoute(array('GET', 'HEAD'), $uri, $action); } public function post($uri, $action) { return $this->addRoute('POST', $uri, $action); } public function put($uri, $action) { return $this->addRoute('PUT', $uri, $action); } public function patch($uri, $action) { return $this->addRoute('PATCH', $uri, $action); } public function delete($uri, $action) { return $this->addRoute('DELETE', $uri, $action); } public function options($uri, $action) { return $this->addRoute('OPTIONS', $uri, $action); } public function any($uri, $action) { $verbs = array('GET', 'HEAD', 'POST', 'PUT', 'PATCH', 'DELETE'); return $this->addRoute($verbs, $uri, $action); } public function match($methods, $uri, $action) { return $this->addRoute($methods, $uri, $action); } public function controllers(array $controllers) { foreach ($controllers as $uri => $name) { $this->controller($uri, $name); } } public function controller($uri, $controller, $names = array()) { $prepended = $controller; if (count($this->groupStack) > 0) { $prepended = $this->prependGroupUses($controller); } $routable = $this->getInspector()->getRoutable($prepended, $uri); foreach ($routable as $method => $routes) { foreach ($routes as $route) { $this->registerInspected($route, $controller, $method, $names); } } $this->addFallthroughRoute($controller, $uri); } protected function registerInspected($route, $controller, $method, &$names) { $action = array('uses' => $controller.'@'.$method); $action['as'] = array_pull($names, $method); $this->{$route['verb']}($route['uri'], $action); } protected function addFallthroughRoute($controller, $uri) { $missing = $this->any($uri.'/{_missing}', $controller.'@missingMethod'); $missing->where('_missing', '(.*)'); } public function resource($name, $controller, array $options = array()) { if (str_contains($name, '/')) { $this->prefixedResource($name, $controller, $options); return; } $base = $this->getResourceWildcard(last(explode('.', $name))); $defaults = $this->resourceDefaults; foreach ($this->getResourceMethods($defaults, $options) as $m) { $this->{'addResource'.ucfirst($m)}($name, $base, $controller, $options); } } protected function prefixedResource($name, $controller, array $options) { list($name, $prefix) = $this->getResourcePrefix($name); $callback = function($me) use ($name, $controller, $options) { $me->resource($name, $controller, $options); }; return $this->group(compact('prefix'), $callback); } protected function getResourcePrefix($name) { $segments = explode('/', $name); $prefix = implode('/', array_slice($segments, 0, -1)); return array($segments[count($segments) - 1], $prefix); } protected function getResourceMethods($defaults, $options) { if (isset($options['only'])) { return array_intersect($defaults, $options['only']); } elseif (isset($options['except'])) { return array_diff($defaults, $options['except']); } return $defaults; } public function getResourceUri($resource) { if ( ! str_contains($resource, '.')) return $resource; $segments = explode('.', $resource); $uri = $this->getNestedResourceUri($segments); return str_replace('/{'.$this->getResourceWildcard(last($segments)).'}', '', $uri); } protected function getNestedResourceUri(array $segments) { return implode('/', array_map(function($s) { return $s.'/{'.$this->getResourceWildcard($s).'}'; }, $segments)); } protected function getResourceAction($resource, $controller, $method, $options) { $name = $this->getResourceName($resource, $method, $options); return array('as' => $name, 'uses' => $controller.'@'.$method); } protected function getResourceName($resource, $method, $options) { if (isset($options['names'][$method])) return $options['names'][$method]; $prefix = isset($options['as']) ? $options['as'].'.' : ''; if (count($this->groupStack) == 0) { return $prefix.$resource.'.'.$method; } return $this->getGroupResourceName($prefix, $resource, $method); } protected function getGroupResourceName($prefix, $resource, $method) { $group = str_replace('/', '.', $this->getLastGroupPrefix()); return trim("{$prefix}{$group}.{$resource}.{$method}", '.'); } public function getResourceWildcard($value) { return str_replace('-', '_', $value); } protected function addResourceIndex($name, $base, $controller, $options) { $action = $this->getResourceAction($name, $controller, 'index', $options); return $this->get($this->getResourceUri($name), $action); } protected function addResourceCreate($name, $base, $controller, $options) { $action = $this->getResourceAction($name, $controller, 'create', $options); return $this->get($this->getResourceUri($name).'/create', $action); } protected function addResourceStore($name, $base, $controller, $options) { $action = $this->getResourceAction($name, $controller, 'store', $options); return $this->post($this->getResourceUri($name), $action); } protected function addResourceShow($name, $base, $controller, $options) { $uri = $this->getResourceUri($name).'/{'.$base.'}'; return $this->get($uri, $this->getResourceAction($name, $controller, 'show', $options)); } protected function addResourceEdit($name, $base, $controller, $options) { $uri = $this->getResourceUri($name).'/{'.$base.'}/edit'; return $this->get($uri, $this->getResourceAction($name, $controller, 'edit', $options)); } protected function addResourceUpdate($name, $base, $controller, $options) { $this->addPutResourceUpdate($name, $base, $controller, $options); return $this->addPatchResourceUpdate($name, $base, $controller); } protected function addPutResourceUpdate($name, $base, $controller, $options) { $uri = $this->getResourceUri($name).'/{'.$base.'}'; return $this->put($uri, $this->getResourceAction($name, $controller, 'update', $options)); } protected function addPatchResourceUpdate($name, $base, $controller) { $uri = $this->getResourceUri($name).'/{'.$base.'}'; $this->patch($uri, $controller.'@update'); } protected function addResourceDestroy($name, $base, $controller, $options) { $action = $this->getResourceAction($name, $controller, 'destroy', $options); return $this->delete($this->getResourceUri($name).'/{'.$base.'}', $action); } public function group(array $attributes, Closure $callback) { $this->updateGroupStack($attributes); call_user_func($callback, $this); array_pop($this->groupStack); } protected function updateGroupStack(array $attributes) { if (count($this->groupStack) > 0) { $attributes = $this->mergeGroup($attributes, last($this->groupStack)); } $this->groupStack[] = $attributes; } public function mergeWithLastGroup($new) { return $this->mergeGroup($new, last($this->groupStack)); } public static function mergeGroup($new, $old) { $new['namespace'] = static::formatUsesPrefix($new, $old); $new['prefix'] = static::formatGroupPrefix($new, $old); if (isset($new['domain'])) unset($old['domain']); return array_merge_recursive(array_except($old, array('namespace', 'prefix')), $new); } protected static function formatUsesPrefix($new, $old) { if (isset($new['namespace'])) { return trim(array_get($old, 'namespace'), '\\').'\\'.trim($new['namespace'], '\\'); } else { return array_get($old, 'namespace'); } } protected static function formatGroupPrefix($new, $old) { if (isset($new['prefix'])) { return trim(array_get($old, 'prefix'), '/').'/'.trim($new['prefix'], '/'); } else { return array_get($old, 'prefix'); } } protected function getLastGroupPrefix() { if (count($this->groupStack) > 0) { return array_get(last($this->groupStack), 'prefix', ''); } return ''; } protected function addRoute($methods, $uri, $action) { return $this->routes->add($this->createRoute($methods, $uri, $action)); } protected function createRoute($methods, $uri, $action) { if ($this->routingToController($action)) { $action = $this->getControllerAction($action); } $route = $this->newRoute( $methods, $uri = $this->prefix($uri), $action ); $route->where($this->patterns); if (count($this->groupStack) > 0) { $this->mergeController($route); } return $route; } protected function newRoute($methods, $uri, $action) { return new Route($methods, $uri, $action); } protected function prefix($uri) { return trim(trim($this->getLastGroupPrefix(), '/').'/'.trim($uri, '/'), '/') ?: '/'; } protected function mergeController($route) { $action = $this->mergeWithLastGroup($route->getAction()); $route->setAction($action); } protected function routingToController($action) { if ($action instanceof Closure) return false; return is_string($action) || is_string(array_get($action, 'uses')); } protected function getControllerAction($action) { if (is_string($action)) $action = array('uses' => $action); if (count($this->groupStack) > 0) { $action['uses'] = $this->prependGroupUses($action['uses']); } $action['controller'] = $action['uses']; $closure = $this->getClassClosure($action['uses']); return array_set($action, 'uses', $closure); } protected function getClassClosure($controller) { $d = $this->getControllerDispatcher(); return function() use ($d, $controller) { $route = $this->current(); $request = $this->getCurrentRequest(); list($class, $method) = explode('@', $controller); return $d->dispatch($route, $request, $class, $method); }; } protected function prependGroupUses($uses) { $group = last($this->groupStack); return isset($group['namespace']) ? $group['namespace'].'\\'.$uses : $uses; } public function dispatch(Request $request) { $this->currentRequest = $request; $response = $this->callFilter('before', $request); if (is_null($response)) { $response = $this->dispatchToRoute($request); } $response = $this->prepareResponse($request, $response); $this->callFilter('after', $request, $response); return $response; } public function dispatchToRoute(Request $request) { $route = $this->findRoute($request); $this->events->fire('router.matched', array($route, $request)); $response = $this->callRouteBefore($route, $request); if (is_null($response)) { $response = $route->run($request); } $response = $this->prepareResponse($request, $response); $this->callRouteAfter($route, $request, $response); return $response; } protected function findRoute($request) { $this->current = $route = $this->routes->match($request); return $this->substituteBindings($route); } protected function substituteBindings($route) { foreach ($route->parameters() as $key => $value) { if (isset($this->binders[$key])) { $route->setParameter($key, $this->performBinding($key, $value, $route)); } } return $route; } protected function performBinding($key, $value, $route) { return call_user_func($this->binders[$key], $value, $route); } public function matched($callback) { $this->events->listen('router.matched', $callback); } public function before($callback) { $this->addGlobalFilter('before', $callback); } public function after($callback) { $this->addGlobalFilter('after', $callback); } protected function addGlobalFilter($filter, $callback) { $this->events->listen('router.'.$filter, $this->parseFilter($callback)); } public function filter($name, $callback) { $this->events->listen('router.filter: '.$name, $this->parseFilter($callback)); } protected function parseFilter($callback) { if (is_string($callback) && ! str_contains($callback, '@')) { return $callback.'@filter'; } else { return $callback; } } public function when($pattern, $name, $methods = null) { if ( ! is_null($methods)) $methods = array_map('strtoupper', (array) $methods); $this->patternFilters[$pattern][] = compact('name', 'methods'); } public function whenRegex($pattern, $name, $methods = null) { if ( ! is_null($methods)) $methods = array_map('strtoupper', (array) $methods); $this->regexFilters[$pattern][] = compact('name', 'methods'); } public function model($key, $class, Closure $callback = null) { return $this->bind($key, function($value) use ($class, $callback) { if (is_null($value)) return null; if ($model = with(new $class)->find($value)) { return $model; } if ($callback instanceof Closure) { return call_user_func($callback); } throw new NotFoundHttpException; }); } public function bind($key, $binder) { $this->binders[str_replace('-', '_', $key)] = $binder; } public function pattern($key, $pattern) { $this->patterns[$key] = $pattern; } protected function callFilter($filter, $request, $response = null) { if ( ! $this->filtering) return null; return $this->events->until('router.'.$filter, array($request, $response)); } public function callRouteBefore($route, $request) { $response = $this->callPatternFilters($route, $request); return $response ?: $this->callAttachedBefores($route, $request); } protected function callPatternFilters($route, $request) { foreach ($this->findPatternFilters($request) as $filter => $parameters) { $response = $this->callRouteFilter($filter, $parameters, $route, $request); if ( ! is_null($response)) return $response; } } public function findPatternFilters($request) { $results = array(); list($path, $method) = array($request->path(), $request->getMethod()); foreach ($this->patternFilters as $pattern => $filters) { if (str_is($pattern, $path)) { $merge = $this->patternsByMethod($method, $filters); $results = array_merge($results, $merge); } } foreach ($this->regexFilters as $pattern => $filters) { if (preg_match($pattern, $path)) { $merge = $this->patternsByMethod($method, $filters); $results = array_merge($results, $merge); } } return $results; } protected function patternsByMethod($method, $filters) { $results = array(); foreach ($filters as $filter) { if ($this->filterSupportsMethod($filter, $method)) { $parsed = Route::parseFilters($filter['name']); $results = array_merge($results, $parsed); } } return $results; } protected function filterSupportsMethod($filter, $method) { $methods = $filter['methods']; return (is_null($methods) || in_array($method, $methods)); } protected function callAttachedBefores($route, $request) { foreach ($route->beforeFilters() as $filter => $parameters) { $response = $this->callRouteFilter($filter, $parameters, $route, $request); if ( ! is_null($response)) return $response; } } public function callRouteAfter($route, $request, $response) { foreach ($route->afterFilters() as $filter => $parameters) { $this->callRouteFilter($filter, $parameters, $route, $request, $response); } } public function callRouteFilter($filter, $parameters, $route, $request, $response = null) { if ( ! $this->filtering) return null; $data = array_merge(array($route, $request, $response), $parameters); return $this->events->until('router.filter: '.$filter, $this->cleanFilterParameters($data)); } protected function cleanFilterParameters(array $parameters) { return array_filter($parameters, function($p) { return ! is_null($p) && $p !== ''; }); } protected function prepareResponse($request, $response) { if ( ! $response instanceof SymfonyResponse) { $response = new Response($response); } return $response->prepare($request); } public function withoutFilters($callback) { $this->disableFilters(); call_user_func($callback); $this->enableFilters(); } public function enableFilters() { $this->filtering = true; } public function disableFilters() { $this->filtering = false; } public function input($key, $default = null) { return $this->current()->parameter($key, $default); } public function getCurrentRoute() { return $this->current(); } public function current() { return $this->current; } public function currentRouteName() { return ($this->current()) ? $this->current()->getName() : null; } public function currentRouteNamed($name) { return ($this->current()) ? $this->current()->getName() == $name : false; } public function currentRouteAction() { $action = $this->current()->getAction(); return isset($action['controller']) ? $action['controller'] : null; } public function currentRouteUses($action) { return $this->currentRouteAction() == $action; } public function getCurrentRequest() { return $this->currentRequest; } public function getRoutes() { return $this->routes; } public function getControllerDispatcher() { if (is_null($this->controllerDispatcher)) { $this->controllerDispatcher = new ControllerDispatcher($this, $this->container); } return $this->controllerDispatcher; } public function setControllerDispatcher(ControllerDispatcher $dispatcher) { $this->controllerDispatcher = $dispatcher; } public function getInspector() { return $this->inspector ?: $this->inspector = new ControllerInspector; } public function handle(SymfonyRequest $request, $type = HttpKernelInterface::MASTER_REQUEST, $catch = true) { return $this->dispatch(Request::createFromBase($request)); } }
