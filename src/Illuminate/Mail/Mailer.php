<?php namespace Illuminate\Mail; use Closure; use Swift_Mailer; use Swift_Message; use Illuminate\Log\Writer; use Illuminate\View\Factory; use Illuminate\Queue\QueueManager; use Illuminate\Container\Container; use Illuminate\Support\SerializableClosure; class Mailer { protected $views; protected $swift; protected $from; protected $logger; protected $container; protected $pretending = false; protected $failedRecipients = array(); public function __construct(Factory $views, Swift_Mailer $swift) { $this->views = $views; $this->swift = $swift; } public function alwaysFrom($address, $name = null) { $this->from = compact('address', 'name'); } public function plain($view, array $data, $callback) { return $this->send(array('text' => $view), $data, $callback); } public function send($view, array $data, $callback) { list($view, $plain) = $this->parseView($view); $data['message'] = $message = $this->createMessage(); $this->callMessageBuilder($callback, $message); $this->addContent($message, $view, $plain, $data); $message = $message->getSwiftMessage(); return $this->sendSwiftMessage($message); } public function queue($view, array $data, $callback, $queue = null) { $callback = $this->buildQueueCallable($callback); $this->queue->push('mailer@handleQueuedMessage', compact('view', 'data', 'callback'), $queue); } public function queueOn($queue, $view, array $data, $callback) { $this->queue($view, $data, $callback, $queue); } public function later($delay, $view, array $data, $callback, $queue = null) { $callback = $this->buildQueueCallable($callback); $this->queue->later($delay, 'mailer@handleQueuedMessage', compact('view', 'data', 'callback'), $queue); } public function laterOn($queue, $delay, $view, array $data, $callback) { $this->later($delay, $view, $data, $callback, $queue); } protected function buildQueueCallable($callback) { if ( ! $callback instanceof Closure) return $callback; return serialize(new SerializableClosure($callback)); } public function handleQueuedMessage($job, $data) { $this->send($data['view'], $data['data'], $this->getQueuedCallable($data)); $job->delete(); } protected function getQueuedCallable(array $data) { if (str_contains($data['callback'], 'SerializableClosure')) { return with(unserialize($data['callback']))->getClosure(); } return $data['callback']; } protected function addContent($message, $view, $plain, $data) { if (isset($view)) { $message->setBody($this->getView($view, $data), 'text/html'); } if (isset($plain)) { $message->addPart($this->getView($plain, $data), 'text/plain'); } } protected function parseView($view) { if (is_string($view)) return array($view, null); if (is_array($view) && isset($view[0])) { return $view; } elseif (is_array($view)) { return array( array_get($view, 'html'), array_get($view, 'text') ); } throw new \InvalidArgumentException("Invalid view."); } protected function sendSwiftMessage($message) { if ( ! $this->pretending) { return $this->swift->send($message, $this->failedRecipients); } elseif (isset($this->logger)) { $this->logMessage($message); return 1; } } protected function logMessage($message) { $emails = implode(', ', array_keys((array) $message->getTo())); $this->logger->info("Pretending to mail message to: {$emails}"); } protected function callMessageBuilder($callback, $message) { if ($callback instanceof Closure) { return call_user_func($callback, $message); } elseif (is_string($callback)) { return $this->container[$callback]->mail($message); } throw new \InvalidArgumentException("Callback is not valid."); } protected function createMessage() { $message = new Message(new Swift_Message); if (isset($this->from['address'])) { $message->from($this->from['address'], $this->from['name']); } return $message; } protected function getView($view, $data) { return $this->views->make($view, $data)->render(); } public function pretend($value = true) { $this->pretending = $value; } public function getViewFactory() { return $this->views; } public function getSwiftMailer() { return $this->swift; } public function failures() { return $this->failedRecipients; } public function setSwiftMailer($swift) { $this->swift = $swift; } public function setLogger(Writer $logger) { $this->logger = $logger; return $this; } public function setQueue(QueueManager $queue) { $this->queue = $queue; return $this; } public function setContainer(Container $container) { $this->container = $container; } }
