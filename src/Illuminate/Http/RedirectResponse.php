<?php namespace Illuminate\Http; use Illuminate\Support\MessageBag; use Illuminate\Support\ViewErrorBag; use Symfony\Component\HttpFoundation\Cookie; use Illuminate\Session\Store as SessionStore; use Illuminate\Support\Contracts\MessageProviderInterface; class RedirectResponse extends \Symfony\Component\HttpFoundation\RedirectResponse { protected $request; protected $session; public function header($key, $value, $replace = true) { $this->headers->set($key, $value, $replace); return $this; } public function with($key, $value = null) { if (is_array($key)) { foreach ($key as $k => $v) $this->with($k, $v); } else { $this->session->flash($key, $value); } return $this; } public function withCookie(Cookie $cookie) { $this->headers->setCookie($cookie); return $this; } public function withInput(array $input = null) { $input = $input ?: $this->request->input(); $this->session->flashInput($input); return $this; } public function onlyInput() { return $this->withInput($this->request->only(func_get_args())); } public function exceptInput() { return $this->withInput($this->request->except(func_get_args())); } public function withErrors($provider, $key = 'default') { $value = $this->parseErrors($provider); $this->session->flash( 'errors', $this->session->get('errors', new ViewErrorBag)->put($key, $value) ); return $this; } protected function parseErrors($provider) { if ($provider instanceof MessageProviderInterface) { return $provider->getMessageBag(); } else { return new MessageBag((array) $provider); } } public function getRequest() { return $this->request; } public function setRequest(Request $request) { $this->request = $request; } public function getSession() { return $this->session; } public function setSession(SessionStore $session) { $this->session = $session; } public function __call($method, $parameters) { if (starts_with($method, 'with')) { return $this->with(snake_case(substr($method, 4)), $parameters[0]); } throw new \BadMethodCallException("Method [$method] does not exist on Redirect."); } }
