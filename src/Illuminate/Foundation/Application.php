<?php namespace Illuminate\Foundation; use Closure; use Illuminate\Http\Request; use Illuminate\Http\Response; use Illuminate\Config\FileLoader; use Illuminate\Container\Container; use Illuminate\Filesystem\Filesystem; use Illuminate\Support\Facades\Facade; use Illuminate\Events\EventServiceProvider; use Illuminate\Routing\RoutingServiceProvider; use Illuminate\Exception\ExceptionServiceProvider; use Illuminate\Config\FileEnvironmentVariablesLoader; use Symfony\Component\HttpKernel\HttpKernelInterface; use Symfony\Component\HttpKernel\TerminableInterface; use Symfony\Component\HttpKernel\Exception\HttpException; use Symfony\Component\Debug\Exception\FatalErrorException; use Illuminate\Support\Contracts\ResponsePreparerInterface; use Symfony\Component\HttpFoundation\Request as SymfonyRequest; use Symfony\Component\HttpFoundation\Response as SymfonyResponse; use Symfony\Component\HttpKernel\Exception\NotFoundHttpException; class Application extends Container implements HttpKernelInterface, TerminableInterface, ResponsePreparerInterface { const VERSION = '4.2-dev'; protected $booted = false; protected $bootingCallbacks = array(); protected $bootedCallbacks = array(); protected $finishCallbacks = array(); protected $shutdownCallbacks = array(); protected $middlewares = array(); protected $serviceProviders = array(); protected $loadedProviders = array(); protected $deferredServices = array(); protected static $requestClass = 'Illuminate\Http\Request'; public function __construct(Request $request = null) { $this->registerBaseBindings($request ?: $this->createNewRequest()); $this->registerBaseServiceProviders(); $this->registerBaseMiddlewares(); } protected function createNewRequest() { return forward_static_call(array(static::$requestClass, 'createFromGlobals')); } protected function registerBaseBindings($request) { $this->instance('request', $request); $this->instance('Illuminate\Container\Container', $this); } protected function registerBaseServiceProviders() { foreach (array('Event', 'Exception', 'Routing') as $name) { $this->{"register{$name}Provider"}(); } } protected function registerExceptionProvider() { $this->register(new ExceptionServiceProvider($this)); } protected function registerRoutingProvider() { $this->register(new RoutingServiceProvider($this)); } protected function registerEventProvider() { $this->register(new EventServiceProvider($this)); } public function bindInstallPaths(array $paths) { $this->instance('path', realpath($paths['app'])); foreach (array_except($paths, array('app')) as $key => $value) { $this->instance("path.{$key}", realpath($value)); } } public static function getBootstrapFile() { return __DIR__.'/start.php'; } public function startExceptionHandling() { $this['exception']->register($this->environment()); $this['exception']->setDebug($this['config']['app.debug']); } public function environment() { if (count(func_get_args()) > 0) { return in_array($this['env'], func_get_args()); } else { return $this['env']; } } public function isLocal() { return $this['env'] == 'local'; } public function detectEnvironment($envs) { $args = isset($_SERVER['argv']) ? $_SERVER['argv'] : null; return $this['env'] = with(new EnvironmentDetector())->detect($envs, $args); } public function runningInConsole() { return php_sapi_name() == 'cli'; } public function runningUnitTests() { return $this['env'] == 'testing'; } public function forceRegister($provider, $options = array()) { return $this->register($provider, $options, true); } public function register($provider, $options = array(), $force = false) { if ($registered = $this->getRegistered($provider) && ! $force) return $registered; if (is_string($provider)) { $provider = $this->resolveProviderClass($provider); } $provider->register(); foreach ($options as $key => $value) { $this[$key] = $value; } $this->markAsRegistered($provider); if ($this->booted) $provider->boot(); return $provider; } public function getRegistered($provider) { $name = is_string($provider) ? $provider : get_class($provider); if (array_key_exists($name, $this->loadedProviders)) { return array_first($this->serviceProviders, function($key, $value) use ($name) { return get_class($value) == $name; }); } } public function resolveProviderClass($provider) { return new $provider($this); } protected function markAsRegistered($provider) { $this['events']->fire($class = get_class($provider), array($provider)); $this->serviceProviders[] = $provider; $this->loadedProviders[$class] = true; } public function loadDeferredProviders() { foreach ($this->deferredServices as $service => $provider) { $this->loadDeferredProvider($service); } $this->deferredServices = array(); } protected function loadDeferredProvider($service) { $provider = $this->deferredServices[$service]; if ( ! isset($this->loadedProviders[$provider])) { $this->registerDeferredProvider($provider, $service); } } public function registerDeferredProvider($provider, $service = null) { if ($service) unset($this->deferredServices[$service]); $this->register($instance = new $provider($this)); if ( ! $this->booted) { $this->booting(function() use ($instance) { $instance->boot(); }); } } public function make($abstract, $parameters = array()) { $abstract = $this->getAlias($abstract); if (isset($this->deferredServices[$abstract])) { $this->loadDeferredProvider($abstract); } return parent::make($abstract, $parameters); } public function before($callback) { return $this['router']->before($callback); } public function after($callback) { return $this['router']->after($callback); } public function finish($callback) { $this->finishCallbacks[] = $callback; } public function shutdown($callback = null) { if (is_null($callback)) { $this->fireAppCallbacks($this->shutdownCallbacks); } else { $this->shutdownCallbacks[] = $callback; } } public function useArraySessions(Closure $callback) { $this->bind('session.reject', function() use ($callback) { return $callback; }); } public function isBooted() { return $this->booted; } public function boot() { if ($this->booted) return; array_walk($this->serviceProviders, function($p) { $p->boot(); }); $this->bootApplication(); } protected function bootApplication() { $this->fireAppCallbacks($this->bootingCallbacks); $this->booted = true; $this->fireAppCallbacks($this->bootedCallbacks); } public function booting($callback) { $this->bootingCallbacks[] = $callback; } public function booted($callback) { $this->bootedCallbacks[] = $callback; if ($this->isBooted()) $this->fireAppCallbacks(array($callback)); } public function run(SymfonyRequest $request = null) { $request = $request ?: $this['request']; $response = with($stack = $this->getStackedClient())->handle($request); $response->send(); $stack->terminate($request, $response); } protected function getStackedClient() { $sessionReject = $this->bound('session.reject') ? $this['session.reject'] : null; $client = with(new \Stack\Builder) ->push('Illuminate\Cookie\Guard', $this['encrypter']) ->push('Illuminate\Cookie\Queue', $this['cookie']) ->push('Illuminate\Session\Middleware', $this['session'], $sessionReject); $this->mergeCustomMiddlewares($client); return $client->resolve($this); } protected function mergeCustomMiddlewares(\Stack\Builder $stack) { foreach ($this->middlewares as $middleware) { list($class, $parameters) = array_values($middleware); array_unshift($parameters, $class); call_user_func_array(array($stack, 'push'), $parameters); } } protected function registerBaseMiddlewares() { } public function middleware($class, array $parameters = array()) { $this->middlewares[] = compact('class', 'parameters'); return $this; } public function forgetMiddleware($class) { $this->middlewares = array_filter($this->middlewares, function($m) use ($class) { return $m['class'] != $class; }); } public function handle(SymfonyRequest $request, $type = HttpKernelInterface::MASTER_REQUEST, $catch = true) { try { $this->refreshRequest($request = Request::createFromBase($request)); $this->boot(); return $this->dispatch($request); } catch (\Exception $e) { if ($this->runningUnitTests()) throw $e; return $this['exception']->handleException($e); } } public function dispatch(Request $request) { if ($this->isDownForMaintenance()) { $response = $this['events']->until('illuminate.app.down'); if ( ! is_null($response)) return $this->prepareResponse($response, $request); } if ($this->runningUnitTests() && ! $this['session']->isStarted()) { $this['session']->start(); } return $this['router']->dispatch($this->prepareRequest($request)); } public function terminate(SymfonyRequest $request, SymfonyResponse $response) { $this->callFinishCallbacks($request, $response); $this->shutdown(); } protected function refreshRequest(Request $request) { $this->instance('request', $request); Facade::clearResolvedInstance('request'); } public function callFinishCallbacks(SymfonyRequest $request, SymfonyResponse $response) { foreach ($this->finishCallbacks as $callback) { call_user_func($callback, $request, $response); } } protected function fireAppCallbacks(array $callbacks) { foreach ($callbacks as $callback) { call_user_func($callback, $this); } } public function prepareRequest(Request $request) { if ( ! is_null($this['config']['session.driver']) && ! $request->hasSession()) { $request->setSession($this['session']->driver()); } return $request; } public function prepareResponse($value) { if ( ! $value instanceof SymfonyResponse) $value = new Response($value); return $value->prepare($this['request']); } public function readyForResponses() { return $this->booted; } public function isDownForMaintenance() { return file_exists($this['config']['app.manifest'].'/down'); } public function down(Closure $callback) { $this['events']->listen('illuminate.app.down', $callback); } public function abort($code, $message = '', array $headers = array()) { if ($code == 404) { throw new NotFoundHttpException($message); } else { throw new HttpException($code, $message, null, $headers); } } public function missing(Closure $callback) { $this->error(function(NotFoundHttpException $e) use ($callback) { return call_user_func($callback, $e); }); } public function error(Closure $callback) { $this['exception']->error($callback); } public function pushError(Closure $callback) { $this['exception']->pushError($callback); } public function fatal(Closure $callback) { $this->error(function(FatalErrorException $e) use ($callback) { return call_user_func($callback, $e); }); } public function getConfigLoader() { return new FileLoader(new Filesystem, $this['path'].'/config'); } public function getEnvironmentVariablesLoader() { return new FileEnvironmentVariablesLoader(new Filesystem, $this['path.base']); } public function getProviderRepository() { $manifest = $this['config']['app.manifest']; return new ProviderRepository(new Filesystem, $manifest); } public function getLoadedProviders() { return $this->loadedProviders; } public function setDeferredServices(array $services) { $this->deferredServices = $services; } public function isDeferredService($service) { return isset($this->deferredServices[$service]); } public static function requestClass($class = null) { if ( ! is_null($class)) static::$requestClass = $class; return static::$requestClass; } public function setRequestForConsoleEnvironment() { $url = $this['config']->get('app.url', 'http://localhost'); $parameters = array($url, 'GET', array(), array(), array(), $_SERVER); $this->refreshRequest(static::onRequest('create', $parameters)); } public static function onRequest($method, $parameters = array()) { return forward_static_call_array(array(static::requestClass(), $method), $parameters); } public function getLocale() { return $this['config']->get('app.locale'); } public function setLocale($locale) { $this['config']->set('app.locale', $locale); $this['translator']->setLocale($locale); $this['events']->fire('locale.changed', array($locale)); } public function registerCoreContainerAliases() { $aliases = array( 'app' => 'Illuminate\Foundation\Application', 'artisan' => 'Illuminate\Console\Application', 'auth' => 'Illuminate\Auth\AuthManager', 'auth.reminder.repository' => 'Illuminate\Auth\Reminders\ReminderRepositoryInterface', 'blade.compiler' => 'Illuminate\View\Compilers\BladeCompiler', 'cache' => 'Illuminate\Cache\CacheManager', 'cache.store' => 'Illuminate\Cache\Repository', 'config' => 'Illuminate\Config\Repository', 'cookie' => 'Illuminate\Cookie\CookieJar', 'encrypter' => 'Illuminate\Encryption\Encrypter', 'db' => 'Illuminate\Database\DatabaseManager', 'events' => 'Illuminate\Events\Dispatcher', 'files' => 'Illuminate\Filesystem\Filesystem', 'form' => 'Illuminate\Html\FormBuilder', 'hash' => 'Illuminate\Hashing\HasherInterface', 'html' => 'Illuminate\Html\HtmlBuilder', 'translator' => 'Illuminate\Translation\Translator', 'log' => 'Illuminate\Log\Writer', 'mailer' => 'Illuminate\Mail\Mailer', 'paginator' => 'Illuminate\Pagination\Factory', 'auth.reminder' => 'Illuminate\Auth\Reminders\PasswordBroker', 'queue' => 'Illuminate\Queue\QueueManager', 'redirect' => 'Illuminate\Routing\Redirector', 'redis' => 'Illuminate\Redis\Database', 'request' => 'Illuminate\Http\Request', 'router' => 'Illuminate\Routing\Router', 'session' => 'Illuminate\Session\SessionManager', 'session.store' => 'Illuminate\Session\Store', 'remote' => 'Illuminate\Remote\RemoteManager', 'url' => 'Illuminate\Routing\UrlGenerator', 'validator' => 'Illuminate\Validation\Factory', 'view' => 'Illuminate\View\Factory', ); foreach ($aliases as $key => $alias) { $this->alias($key, $alias); } } public function __get($key) { return $this[$key]; } public function __set($key, $value) { $this[$key] = $value; } }
